# Build script for Pankha Windows Agent

param(
    [string]$Configuration = "Release",
    [string]$Version,  # Allow passing version explicitly (e.g. from CI)
    [switch]$Clean,
    [switch]$Test,
    [switch]$Publish,
    [switch]$BuildInstaller,
    [switch]$Menu
)

# Function to get version from Git
function Get-GitVersion {
    try {
        $gitVersion = git describe --tags --always --dirty
        # Remove 'v' prefix if present
        if ($gitVersion.StartsWith("v")) {
            $gitVersion = $gitVersion.Substring(1)
        }
        return $gitVersion
    } catch {
        return "0.0.0"
    }
}

# Determine Version and InfoVersion
if ([string]::IsNullOrWhiteSpace($Version)) {
    $InfoVersion = Get-GitVersion
} else {
    $InfoVersion = $Version -replace '^v', ''
}

# Normalize 4-part version to SemVer prerelease format for InfoVersion: 0.1.7.1 -> 0.1.7-1
# This matches the logic in .github/workflows/release-public.yml used for Rust agents.
# We use greedy matching for the 4th part and preserve any remaining suffix (e.g., 0.1.7.6-alpha -> 0.1.7-6-alpha)
if ($InfoVersion -match '^(\d+\.\d+\.\d+)\.(\d+)(.*)$') {
    # Keep original 4-part (including suffix if present) for AssemblyVersion/FileVersion
    # Note: AssemblyVersion/FileVersion usually only support numbers, so we might need to strip suffixes for $Version
    $VersionOnly = $Matches[1] + "." + $Matches[2]
    # Convert to SemVer for InformationalVersion
    $InfoVersion = "$($Matches[1])-$($Matches[2])$($Matches[3])"
    $Version = $VersionOnly
    Write-Host "⚠️  Converting: $($Matches[0]) -> $($InfoVersion) (SemVer format for parity)" -ForegroundColor Yellow
} else {
    # Extract only the numeric part for AssemblyVersion/FileVersion
    if ($InfoVersion -match '^(\d+(\.\d+){0,3})') {
        $Version = $Matches[1]
    } else {
        $Version = "0.0.0"
    }
}
Write-Host "Final Versions - FileVersion: $Version | InfoVersion: $InfoVersion" -ForegroundColor Gray


# Function to check if running as administrator
function Test-Administrator {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

# Function to elevate to administrator
function Start-ElevatedProcess {
    param([string]$Arguments)

    $scriptPath = $MyInvocation.PSCommandPath
    if (-not $scriptPath) {
        $scriptPath = $PSCommandPath
    }

    Write-Host "Requesting administrator privileges..." -ForegroundColor Yellow
    Start-Process powershell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" $Arguments" -Verb RunAs -Wait
    exit
}

# Function to generate C# code from ui-options.json
function Generate-UIOptionsCode {
    param(
        [Parameter(Mandatory=$true)]
        [string]$JsonPath,
        [Parameter(Mandatory=$true)]
        [string]$OutputPath
    )

    Write-Host "Generating C# code from ui-options.json..." -ForegroundColor Yellow

    # Verify JSON file exists
    if (-not (Test-Path $JsonPath)) {
        Write-Host "❌ ERROR: ui-options.json not found at: $JsonPath" -ForegroundColor Red
        Write-Host "   Build cannot continue without single source of truth for dropdown values." -ForegroundColor Red
        exit 1
    }

    try {
        # Parse JSON
        $jsonContent = Get-Content $JsonPath -Raw -ErrorAction Stop
        $json = $jsonContent | ConvertFrom-Json -ErrorAction Stop
        $options = $json.options

        if ($null -eq $options) {
            Write-Host "❌ ERROR: 'options' key not found in ui-options.json" -ForegroundColor Red
            exit 1
        }

        # Helper function to format array values
        function Format-SimpleArray {
            param([array]$Values)
            return ($Values | ForEach-Object { $_ }) -join ', '
        }

        # Helper function to format tuple arrays
        function Format-TupleArray {
            param([array]$Values, [string]$ValueType)
            $formatted = $Values | ForEach-Object {
                if ($ValueType -eq "string") {
                    "        (`"$($_.value)`", `"$($_.label)`")"
                } elseif ($ValueType -eq "int") {
                    "        ($($_.value), `"$($_.label)`")"
                } else {
                    "        ($($_.value), `"$($_.label)`")"
                }
            }
            return $formatted -join ",`n"
        }

        # Build C# code
        $code = @"
// Auto generated from "ui-options.json"
// DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED BY build.ps1
// Last generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
//
// This file is generated from frontend/src/config/ui-options.json (single source of truth)
// to ensure frontend and tray application use identical dropdown values, labels, and tooltips.

namespace Pankha.Tray.Models;

/// <summary>
/// UI dropdown options - auto-generated from ui-options.json
/// Generated at build-time by build.ps1
/// </summary>
public static class UIOptionsAutoGenerated
{
    // ========== DROPDOWN VALUES ==========

    /// <summary>
    /// Agent update intervals in seconds with display labels
    /// </summary>
    public static readonly (double Value, string Label)[] UpdateIntervals =
    {
$(Format-TupleArray $options.updateInterval.values "double")
    };

    /// <summary>
    /// Fan step percentage options with display labels
    /// </summary>
    public static readonly (int Value, string Label)[] FanSteps =
    {
$(Format-TupleArray $options.fanStep.values "int")
    };

    /// <summary>
    /// Hysteresis temperature options with display labels
    /// </summary>
    public static readonly (double Value, string Label)[] HysteresisOptions =
    {
$(Format-TupleArray $options.hysteresis.values "double")
    };

    /// <summary>
    /// Emergency temperature threshold options in °C with display labels
    /// </summary>
    public static readonly (int Value, string Label)[] EmergencyTemps =
    {
$(Format-TupleArray $options.emergencyTemp.values "int")
    };

    /// <summary>
    /// Log level options with display labels
    /// </summary>
    public static readonly (string Value, string Label)[] LogLevels =
    {
$(Format-TupleArray $options.logLevel.values "string")
    };

    /// <summary>
    /// Failsafe speed options (percentage) - fan speed when backend disconnected
    /// </summary>
    public static readonly (int Value, string Label)[] FailsafeSpeedOptions =
    {
$(Format-TupleArray $options.failsafeSpeed.values "int")
    };

    // ========== LABELS ==========

    public static readonly string FanControlLabel = "$($options.fanControl.label)";
    public static readonly string LogLevelLabel = "$($options.logLevel.label)";
    public static readonly string EmergencyTempLabel = "$($options.emergencyTemp.label)";
    public static readonly string FailsafeSpeedLabel = "$($options.failsafeSpeed.label)";
    public static readonly string UpdateIntervalLabel = "$($options.updateInterval.label)";
    public static readonly string FanStepLabel = "$($options.fanStep.label)";
    public static readonly string HysteresisLabel = "$($options.hysteresis.label)";

    // ========== TOOLTIPS (with placeholders) ==========

    public static readonly string FanControlTooltip = @"$($options.fanControl.tooltip -replace '"', '""')";
    public static readonly string LogLevelTooltip = @"$($options.logLevel.tooltip -replace '"', '""')";
    public static readonly string EmergencyTempTooltip = @"$($options.emergencyTemp.tooltip -replace '"', '""')";
    public static readonly string FailsafeSpeedTooltip = @"$($options.failsafeSpeed.tooltip -replace '"', '""')";
    public static readonly string UpdateIntervalTooltip = @"$($options.updateInterval.tooltip -replace '"', '""')";
    public static readonly string FanStepTooltip = @"$($options.fanStep.tooltip -replace '"', '""')";
    public static readonly string HysteresisTooltip = @"$($options.hysteresis.tooltip -replace '"', '""')";

    /// <summary>
    /// Interpolate placeholders like {agentInterval} in tooltip strings
    /// </summary>
    public static string InterpolateTooltip(string template, Dictionary<string, object> values)
    {
        if (string.IsNullOrEmpty(template) || values == null) return template;
        foreach (var kv in values)
        {
            template = template.Replace($"{{{kv.Key}}}", kv.Value?.ToString() ?? "");
        }
        return template;
    }

    // ========== VALIDATION ARRAYS (values only, for CommandHandler) ==========

    /// <summary>Valid update interval values in seconds</summary>
    public static readonly double[] ValidUpdateIntervals = UpdateIntervals.Select(x => x.Value).ToArray();

    /// <summary>Valid fan step percentage values</summary>
    public static readonly int[] ValidFanSteps = FanSteps.Select(x => x.Value).ToArray();

    /// <summary>Valid hysteresis temperature values in °C</summary>
    public static readonly double[] ValidHysteresis = HysteresisOptions.Select(x => x.Value).ToArray();

    /// <summary>Valid emergency temperature values in °C</summary>
    public static readonly int[] ValidEmergencyTemps = EmergencyTemps.Select(x => x.Value).ToArray();

    /// <summary>Valid log level values</summary>
    public static readonly string[] ValidLogLevels = LogLevels.Select(x => x.Value).ToArray();

    /// <summary>Valid failsafe speed percentage values</summary>
    public static readonly int[] ValidFailsafeSpeeds = FailsafeSpeedOptions.Select(x => x.Value).ToArray();
}
"@

        # Write generated file
        $code | Out-File -FilePath $OutputPath -Encoding UTF8 -ErrorAction Stop
        Write-Host "✅ Generated: $OutputPath" -ForegroundColor Green

    } catch {
        Write-Host "❌ ERROR: Failed to generate ui-options_auto-generated.cs" -ForegroundColor Red
        Write-Host "   Error: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "   Build cannot continue." -ForegroundColor Red
        exit 1
    }
}

# Read build configuration
$ConfigPath = Join-Path $PSScriptRoot "build-config.json"
if (-not (Test-Path $ConfigPath)) {
    Write-Host "❌ build-config.json not found!" -ForegroundColor Red
    exit 1
}
$Config = Get-Content $ConfigPath | ConvertFrom-Json

# Show interactive menu if no parameters provided
$hasParams = $PSBoundParameters.Count -gt 0 -and -not $Menu
if (-not $hasParams -or $Menu) {
    Write-Host ""
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host " Pankha Windows Agent - Build Menu" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "  1. Build Full Release (Clean + Publish + MSI)" -ForegroundColor Green
    Write-Host "  2. Clean + Publish Agent Only (Single-File EXE)" -ForegroundColor Cyan
    Write-Host "  3. Publish Agent Only (Single-File EXE)" -ForegroundColor Cyan
    Write-Host "  4. Build Only (Quick check for build errors)" -ForegroundColor White
    Write-Host "  5. Run Hardware Test" -ForegroundColor Magenta
    Write-Host "  6. Cleanup" -ForegroundColor Yellow
    Write-Host "  0. Exit" -ForegroundColor Red
    Write-Host ""
    $choice = Read-Host "Select option"

    switch ($choice) {
        "1" { $Clean = $true; $Publish = $true; $BuildInstaller = $true }
        "2" { $Clean = $true; $Publish = $true }
        "3" { $Publish = $true }
        "4" { <# Standard build - no flags needed #> }
        "5" {
            # Auto-elevate for hardware test
            if (-not (Test-Administrator)) {
                Start-ElevatedProcess "-Test"
            }
            $Test = $true
        }
        "6" { $Clean = $true }
        "0" { Write-Host "Exiting..." -ForegroundColor Gray; exit 0 }
        default { Write-Host "Invalid option" -ForegroundColor Red; exit 1 }
    }
    Write-Host ""
}

# Auto-elevate for Test parameter (when run with -Test directly)
if ($Test -and -not (Test-Administrator)) {
    Start-ElevatedProcess "-Test"
}

Write-Host "=== Pankha Windows Agent Build Script ===" -ForegroundColor Cyan
Write-Host ""

# Clean if requested
if ($Clean) {
    Write-Host "Cleaning previous builds..." -ForegroundColor Yellow
    dotnet clean -c $Configuration
    if (Test-Path "bin") { Remove-Item -Recurse -Force "bin" }
    if (Test-Path "obj") { Remove-Item -Recurse -Force "obj" }
    if (Test-Path "publish") { Remove-Item -Recurse -Force "publish" }

    # Also clean installer cache if building MSI
    if ($BuildInstaller -and (Test-Path "installer")) {
        Write-Host "  Cleaning installer cache..." -ForegroundColor Gray
        if (Test-Path "installer\bin") { Remove-Item -Recurse -Force "installer\bin" }
        if (Test-Path "installer\obj") { Remove-Item -Recurse -Force "installer\obj" }
    }

    # Clean Tray app artifacts
    if (Test-Path "Pankha.Tray\bin") { Remove-Item -Recurse -Force "Pankha.Tray\bin" }
    if (Test-Path "Pankha.Tray\obj") { Remove-Item -Recurse -Force "Pankha.Tray\obj" }

    Write-Host "✅ Clean complete" -ForegroundColor Green
    Write-Host ""
}

# Restore packages
Write-Host "Restoring NuGet packages..." -ForegroundColor Yellow
dotnet restore
if ($LASTEXITCODE -ne 0) {
    Write-Host "❌ Restore (Agent) failed" -ForegroundColor Red
    exit 1
}
dotnet restore "Pankha.Tray\Pankha.Tray.csproj"
if ($LASTEXITCODE -ne 0) {
    Write-Host "❌ Restore (Tray) failed" -ForegroundColor Red
    exit 1
}
Write-Host "✅ Restore complete" -ForegroundColor Green
Write-Host ""

# Generate C# code from ui-options.json (single source of truth)
Write-Host "=== Code Generation ===" -ForegroundColor Cyan
$UIOptionsJson = Join-Path $PSScriptRoot "..\..\..\..\frontend\src\config\ui-options.json"
$GeneratedFile = Join-Path $PSScriptRoot "Pankha.Tray\Models\ui-options_auto-generated.cs"

Generate-UIOptionsCode -JsonPath $UIOptionsJson -OutputPath $GeneratedFile
Write-Host ""

# Resolve Icon Path from Config (for MSBuild injection)
$AppIconPath = $null
if ($Config.Paths.AppIcon_256) {
    $AppIconPath = Join-Path $PSScriptRoot $Config.Paths.AppIcon_256
    if (-not (Test-Path $AppIconPath)) {
         Write-Host "WARNING: Configured icon not found at $AppIconPath" -ForegroundColor Yellow
    }
}

# Generate Directory.Build.props to control AssemblyName from build-config.json
$PropsPath = Join-Path $PSScriptRoot "Directory.Build.props"
$AgentExeName = [System.IO.Path]::GetFileNameWithoutExtension($Config.Filenames.AgentExe)

$PropsContent = @"
<Project>
  <PropertyGroup>
    <AssemblyName>$AgentExeName</AssemblyName>
    <Version>$InfoVersion</Version>
    <FileVersion>$Version</FileVersion>
    <AssemblyVersion>$Version</AssemblyVersion>
    <InformationalVersion>$InfoVersion</InformationalVersion>
    <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
  </PropertyGroup>
</Project>
"@
$PropsContent | Out-File -FilePath $PropsPath -Encoding UTF8 -Force
Write-Host "Generated Directory.Build.props with AssemblyName: $AgentExeName" -ForegroundColor Gray

# Build
# Optimization: Skip explicit build if we are going to publish (which does a build)
if (-not $Publish) {
    Write-Host "Building ($Configuration)..." -ForegroundColor Yellow
    $BuildParams = @("-c", $Configuration)
    if ($AppIconPath) { $BuildParams += "/p:ApplicationIcon=`"$AppIconPath`"" }

    dotnet build @BuildParams
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Build failed" -ForegroundColor Red
        exit 1
    }
    Write-Host "✅ Build complete" -ForegroundColor Green
    Write-Host ""
} else {
    Write-Host "Skipping explicit build (will be built during publish)..." -ForegroundColor Gray
}

Write-Host "✅ Build complete" -ForegroundColor Green
Write-Host ""

# Build Tray App
# Optimization: Skip explicit build if we are going to publish
if (-not $Publish) {
    Write-Host "Building Tray App ($Configuration)..." -ForegroundColor Yellow
    $TrayBuildParams = @("Pankha.Tray\Pankha.Tray.csproj", "-c", $Configuration)
    if ($AppIconPath) { $TrayBuildParams += "/p:AppIconPath=`"$AppIconPath`"" }
    dotnet build @TrayBuildParams
    Write-Host "✅ Tray App Build complete" -ForegroundColor Green
    Write-Host ""
}

# Test if requested
if ($Test) {
    Write-Host "Running hardware discovery test..." -ForegroundColor Yellow
    dotnet run -c $Configuration -- --test
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Test failed" -ForegroundColor Red
        exit 1
    }
    Write-Host "✅ Test complete" -ForegroundColor Green
    Write-Host ""
}

# Publish if requested
if ($Publish) {
    Write-Host "Publishing single-file executable..." -ForegroundColor Yellow

    # Resolve relative path from config
    $OutputDir = Join-Path $PSScriptRoot $Config.Paths.BuildArtifacts
    
    # Clean output dir
    if (Test-Path $OutputDir) { Remove-Item -Recurse -Force $OutputDir }

    $PublishArgs = @(
        "-c", "Release",
        "-r", "win-x64",
        "--self-contained", "true",
        "/p:PublishSingleFile=true",
        "/p:IncludeNativeLibrariesForSelfExtract=true",
        "/p:PublishReadyToRun=true",
        "-o", $OutputDir
    )
    if ($AppIconPath) { $PublishArgs += "/p:ApplicationIcon=`"$AppIconPath`"" }

    dotnet publish @PublishArgs

    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Publish failed" -ForegroundColor Red
        exit 1
    }

    # Publish Tray App
    Write-Host "Publishing Tray App..." -ForegroundColor Yellow
    $TrayPublishArgs = @(
        "Pankha.Tray\Pankha.Tray.csproj",
        "-c", "Release",
        "-r", "win-x64",
        "--self-contained", "true",
        "/p:PublishSingleFile=true",
        "/p:IncludeNativeLibrariesForSelfExtract=true",
        "-o", $OutputDir
    )
    if ($AppIconPath) {
        $TrayPublishArgs += "/p:ApplicationIcon=`"$AppIconPath`""
        $TrayPublishArgs += "/p:AppIconPath=`"$AppIconPath`""
    }

    dotnet publish @TrayPublishArgs
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Tray App Publish failed" -ForegroundColor Red
        exit 1
    }

    # Rename Tray Executable
    $DefaultTrayName = "Pankha.Tray.exe"
    $TargetTrayName = $Config.Filenames.AgentUI

    if ($TargetTrayName -and $TargetTrayName -ne $DefaultTrayName) {
        $SourceTray = Join-Path $OutputDir $DefaultTrayName
        $TargetTray = Join-Path $OutputDir $TargetTrayName
        if (Test-Path $SourceTray) {
            Move-Item -Force $SourceTray $TargetTray
            Write-Host "Renamed Tray executable to: $TargetTrayName" -ForegroundColor Gray
        }
    }

    # Copy configuration example
    Copy-Item "config.example.json" "$OutputDir\config.example.json"

    # Note: ui-options.json is embedded as a resource in Pankha.Tray at build-time
    # (from frontend/src/config/ui-options.json) - no runtime file needed

    # Rename Executable if needed (Default is project name pankha-agent-windows.exe)
    # If Config.Filenames.AgentExe differs, we rename it.
    
    $TargetExeName = $Config.Filenames.AgentExe
    $ExpectedOutput = Join-Path $OutputDir $TargetExeName

    if (-not (Test-Path $ExpectedOutput)) {
        # Fallback: Check if it was output with default name (if props failed)
        $DefaultProjectName = "pankha-agent-windows.exe"
        $PossibleDefault = Join-Path $OutputDir $DefaultProjectName
        if (Test-Path $PossibleDefault) {
             Move-Item -Force $PossibleDefault $ExpectedOutput
             Write-Host "Renamed executable to: $TargetExeName" -ForegroundColor Gray
        } else {
             # It might already be named correctly if Directory.Build.props worked
             # But if Test-Path $ExpectedOutput failed, then it's NOT there.
             # So we warn.
             Write-Host "WARNING: Expected executable not found at $ExpectedOutput" -ForegroundColor Yellow
        }
    }

    Write-Host "✅ Publish complete" -ForegroundColor Green
    Write-Host ""
    Write-Host "Output: $OutputDir\$TargetExeName" -ForegroundColor Cyan

    # Show file size
    $ExePath = "$OutputDir\$TargetExeName"
    if (Test-Path $ExePath) {
        $Size = (Get-Item $ExePath).Length / 1MB
        Write-Host "Size: $($Size.ToString('F2')) MB" -ForegroundColor Cyan
    }
}

# Build MSI installer if requested (WixSharp)
if ($BuildInstaller) {
    Write-Host ""
    Write-Host "=== Building WixSharp MSI Installer ===" -ForegroundColor Cyan
    Write-Host ""

    Push-Location installer
    try {
        # Call the WixSharp build script
        $buildArgs = @()
        if ($Clean) {
            $buildArgs += "-Clean"
        }

        Write-Host "Running WixSharp installer builder..." -ForegroundColor Yellow
        & .\build-wixsharp.ps1 @buildArgs

        if ($LASTEXITCODE -ne 0) {
            throw "WixSharp installer build failed"
        }

        Write-Host ""
        Write-Host "✅ MSI Installer build complete!" -ForegroundColor Green
        Write-Host ""

        # Show MSI location - Resolve from Config
        $MsiOutputDir = Join-Path $PSScriptRoot $Config.Paths.InstallerOutput
        $MsiFileName = $Config.Filenames.InstallerMsi
        $MsiPath = Join-Path $MsiOutputDir $MsiFileName
        
        if (Test-Path $MsiPath) {
            $MsiSize = (Get-Item $MsiPath).Length / 1MB
            Write-Host "========================================" -ForegroundColor Cyan
            Write-Host " MSI Installer Ready!" -ForegroundColor Green
            Write-Host "========================================" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "Location: $MsiPath" -ForegroundColor Cyan
            Write-Host "Size: $($MsiSize.ToString('F2')) MB" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "To install:" -ForegroundColor Yellow
            Write-Host "  msiexec /i `"$MsiPath`" /l*v install.log" -ForegroundColor Gray
            Write-Host "  (or double-click the MSI file)" -ForegroundColor Gray
            Write-Host ""
            Write-Host "To uninstall:" -ForegroundColor Yellow
            Write-Host "  msiexec /x `"$MsiPath`" /l*v uninstall.log" -ForegroundColor Gray
            Write-Host ""
        }
    }
    catch {
        Write-Host "❌ Installer build failed: $_" -ForegroundColor Red
        Pop-Location
        exit 1
    }
    finally {
        Pop-Location
    }
}

Write-Host ""
Write-Host "Finished at: $(Get-Date -Format 'yyyy-MM-dd hh:mm:ss tt')" -ForegroundColor Gray
Write-Host "=== Build Complete ===" -ForegroundColor Cyan
