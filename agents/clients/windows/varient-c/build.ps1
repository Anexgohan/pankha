# Build script for Pankha Windows Agent

param(
    [string]$Configuration = "Release",
    [string]$Version,  # Allow passing version explicitly (e.g. from CI)
    [switch]$Clean,
    [switch]$Test,
    [switch]$Publish,
    [switch]$BuildInstaller,
    [switch]$Menu
)

# Function to get version from Git
function Get-GitVersion {
    try {
        $gitVersion = git describe --tags --always --dirty
        # Remove 'v' prefix if present
        if ($gitVersion.StartsWith("v")) {
            $gitVersion = $gitVersion.Substring(1)
        }
        return $gitVersion
    } catch {
        return "0.0.0"
    }
}

# Determine Version
if ([string]::IsNullOrWhiteSpace($Version)) {
    $Version = Get-GitVersion
    Write-Host "Auto-detected Version: $Version" -ForegroundColor Gray
} else {
    Write-Host "Using Version: $Version" -ForegroundColor Gray
}


# Function to check if running as administrator
function Test-Administrator {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    return $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

# Function to elevate to administrator
function Start-ElevatedProcess {
    param([string]$Arguments)

    $scriptPath = $MyInvocation.PSCommandPath
    if (-not $scriptPath) {
        $scriptPath = $PSCommandPath
    }

    Write-Host "Requesting administrator privileges..." -ForegroundColor Yellow
    Start-Process powershell.exe -ArgumentList "-NoProfile -ExecutionPolicy Bypass -File `"$scriptPath`" $Arguments" -Verb RunAs -Wait
    exit
}

# Function to generate C# code from ui-options.json
function Generate-UIOptionsCode {
    param(
        [Parameter(Mandatory=$true)]
        [string]$JsonPath,
        [Parameter(Mandatory=$true)]
        [string]$OutputPath
    )

    Write-Host "Generating C# code from ui-options.json..." -ForegroundColor Yellow

    # Verify JSON file exists
    if (-not (Test-Path $JsonPath)) {
        Write-Host "❌ ERROR: ui-options.json not found at: $JsonPath" -ForegroundColor Red
        Write-Host "   Build cannot continue without single source of truth for dropdown values." -ForegroundColor Red
        exit 1
    }

    try {
        # Parse JSON
        $jsonContent = Get-Content $JsonPath -Raw -ErrorAction Stop
        $json = $jsonContent | ConvertFrom-Json -ErrorAction Stop
        $options = $json.options

        if ($null -eq $options) {
            Write-Host "❌ ERROR: 'options' key not found in ui-options.json" -ForegroundColor Red
            exit 1
        }

        # Helper function to format array values
        function Format-SimpleArray {
            param([array]$Values)
            return ($Values | ForEach-Object { $_ }) -join ', '
        }

        # Helper function to format tuple arrays
        function Format-TupleArray {
            param([array]$Values, [string]$ValueType)
            $formatted = $Values | ForEach-Object {
                if ($ValueType -eq "string") {
                    "        (`"$($_.value)`", `"$($_.label)`")"
                } elseif ($ValueType -eq "int") {
                    "        ($($_.value), `"$($_.label)`")"
                } else {
                    "        ($($_.value), `"$($_.label)`")"
                }
            }
            return $formatted -join ",`n"
        }

        # Build C# code
        $code = @"
// Auto generated from "ui-options.json"
// DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED BY build.ps1
// Last generated: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
//
// This file is generated from frontend/src/config/ui-options.json (single source of truth)
// to ensure frontend and tray application use identical dropdown values.

namespace Pankha.Tray.Models;

/// <summary>
/// UI dropdown options - auto-generated from ui-options.json
/// Generated at build-time by build.ps1
/// </summary>
public static class UIOptionsAutoGenerated
{
    /// <summary>
    /// Agent update intervals in seconds
    /// </summary>
    public static readonly double[] UpdateIntervals = { $(Format-SimpleArray $options.updateInterval.values) };

    /// <summary>
    /// Sensor deduplication tolerance values in °C
    /// </summary>
    public static readonly double[] SensorTolerances = { $(Format-SimpleArray $options.sensorTolerance.values) };

    /// <summary>
    /// Fan step percentage options with display labels
    /// </summary>
    public static readonly (int Value, string Label)[] FanSteps =
    {
$(Format-TupleArray $options.fanStep.values "int")
    };

    /// <summary>
    /// Hysteresis temperature options with display labels
    /// </summary>
    public static readonly (double Value, string Label)[] HysteresisOptions =
    {
$(Format-TupleArray $options.hysteresis.values "double")
    };

    /// <summary>
    /// Emergency temperature threshold options in °C
    /// </summary>
    public static readonly int[] EmergencyTemps = { $(Format-SimpleArray $options.emergencyTemp.values) };

    /// <summary>
    /// Log level options with display labels
    /// </summary>
    public static readonly (string Value, string Label)[] LogLevels =
    {
$(Format-TupleArray $options.logLevel.values "string")
    };
}
"@

        # Write generated file
        $code | Out-File -FilePath $OutputPath -Encoding UTF8 -ErrorAction Stop
        Write-Host "✅ Generated: $OutputPath" -ForegroundColor Green

    } catch {
        Write-Host "❌ ERROR: Failed to generate ui-options_auto-generated.cs" -ForegroundColor Red
        Write-Host "   Error: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "   Build cannot continue." -ForegroundColor Red
        exit 1
    }
}

# Read build configuration
$ConfigPath = Join-Path $PSScriptRoot "build-config.json"
if (-not (Test-Path $ConfigPath)) {
    Write-Host "❌ build-config.json not found!" -ForegroundColor Red
    exit 1
}
$Config = Get-Content $ConfigPath | ConvertFrom-Json

# Show interactive menu if no parameters provided
$hasParams = $PSBoundParameters.Count -gt 0 -and -not $Menu
if (-not $hasParams -or $Menu) {
    Write-Host ""
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host " Pankha Windows Agent - Build Menu" -ForegroundColor Cyan
    Write-Host "========================================" -ForegroundColor Cyan
    Write-Host ""
    Write-Host "  1. Build Full Release (Clean + Publish + MSI)" -ForegroundColor Green
    Write-Host "  2. Clean + Publish Agent Only (Single-File EXE)" -ForegroundColor Cyan
    Write-Host "  3. Publish Agent Only (Single-File EXE)" -ForegroundColor Cyan
    Write-Host "  4. Build Only (Quick check for build errors)" -ForegroundColor White
    Write-Host "  5. Run Hardware Test" -ForegroundColor Magenta
    Write-Host "  6. Cleanup" -ForegroundColor Yellow
    Write-Host "  0. Exit" -ForegroundColor Red
    Write-Host ""
    $choice = Read-Host "Select option"

    switch ($choice) {
        "1" { $Clean = $true; $Publish = $true; $BuildInstaller = $true }
        "2" { $Clean = $true; $Publish = $true }
        "3" { $Publish = $true }
        "4" { <# Standard build - no flags needed #> }
        "5" {
            # Auto-elevate for hardware test
            if (-not (Test-Administrator)) {
                Start-ElevatedProcess "-Test"
            }
            $Test = $true
        }
        "6" { $Clean = $true }
        "0" { Write-Host "Exiting..." -ForegroundColor Gray; exit 0 }
        default { Write-Host "Invalid option" -ForegroundColor Red; exit 1 }
    }
    Write-Host ""
}

# Auto-elevate for Test parameter (when run with -Test directly)
if ($Test -and -not (Test-Administrator)) {
    Start-ElevatedProcess "-Test"
}

Write-Host "=== Pankha Windows Agent Build Script ===" -ForegroundColor Cyan
Write-Host ""

# Clean if requested
if ($Clean) {
    Write-Host "Cleaning previous builds..." -ForegroundColor Yellow
    dotnet clean -c $Configuration
    if (Test-Path "bin") { Remove-Item -Recurse -Force "bin" }
    if (Test-Path "obj") { Remove-Item -Recurse -Force "obj" }
    if (Test-Path "publish") { Remove-Item -Recurse -Force "publish" }

    # Also clean installer cache if building MSI
    if ($BuildInstaller -and (Test-Path "installer")) {
        Write-Host "  Cleaning installer cache..." -ForegroundColor Gray
        if (Test-Path "installer\bin") { Remove-Item -Recurse -Force "installer\bin" }
        if (Test-Path "installer\obj") { Remove-Item -Recurse -Force "installer\obj" }
    }

    # Clean Tray app artifacts
    if (Test-Path "Pankha.Tray\bin") { Remove-Item -Recurse -Force "Pankha.Tray\bin" }
    if (Test-Path "Pankha.Tray\obj") { Remove-Item -Recurse -Force "Pankha.Tray\obj" }

    Write-Host "✅ Clean complete" -ForegroundColor Green
    Write-Host ""
}

# Restore packages
Write-Host "Restoring NuGet packages..." -ForegroundColor Yellow
dotnet restore
if ($LASTEXITCODE -ne 0) {
    Write-Host "❌ Restore (Agent) failed" -ForegroundColor Red
    exit 1
}
dotnet restore "Pankha.Tray\Pankha.Tray.csproj"
if ($LASTEXITCODE -ne 0) {
    Write-Host "❌ Restore (Tray) failed" -ForegroundColor Red
    exit 1
}
Write-Host "✅ Restore complete" -ForegroundColor Green
Write-Host ""

# Generate C# code from ui-options.json (single source of truth)
Write-Host "=== Code Generation ===" -ForegroundColor Cyan
$UIOptionsJson = Join-Path $PSScriptRoot "..\..\..\..\frontend\src\config\ui-options.json"
$GeneratedFile = Join-Path $PSScriptRoot "Pankha.Tray\Models\ui-options_auto-generated.cs"

Generate-UIOptionsCode -JsonPath $UIOptionsJson -OutputPath $GeneratedFile
Write-Host ""

# Resolve Icon Path from Config (for MSBuild injection)
$AppIconPath = $null
if ($Config.Paths.AppIcon_256) {
    $AppIconPath = Join-Path $PSScriptRoot $Config.Paths.AppIcon_256
    if (-not (Test-Path $AppIconPath)) {
         Write-Host "WARNING: Configured icon not found at $AppIconPath" -ForegroundColor Yellow
    }
}

# Generate Directory.Build.props to control AssemblyName from build-config.json
$PropsPath = Join-Path $PSScriptRoot "Directory.Build.props"
$AgentExeName = [System.IO.Path]::GetFileNameWithoutExtension($Config.Filenames.AgentExe)

$PropsContent = @"
<Project>
  <PropertyGroup>
    <AssemblyName>$AgentExeName</AssemblyName>
    <Version>$Version</Version>
    <FileVersion>$Version</FileVersion>
    <AssemblyVersion>$Version</AssemblyVersion>
  </PropertyGroup>
</Project>
"@
$PropsContent | Out-File -FilePath $PropsPath -Encoding UTF8 -Force
Write-Host "Generated Directory.Build.props with AssemblyName: $AgentExeName" -ForegroundColor Gray

# Build
# Optimization: Skip explicit build if we are going to publish (which does a build)
if (-not $Publish) {
    Write-Host "Building ($Configuration)..." -ForegroundColor Yellow
    $BuildParams = @("-c", $Configuration)
    if ($AppIconPath) { $BuildParams += "/p:ApplicationIcon=`"$AppIconPath`"" }

    dotnet build @BuildParams
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Build failed" -ForegroundColor Red
        exit 1
    }
    Write-Host "✅ Build complete" -ForegroundColor Green
    Write-Host ""
} else {
    Write-Host "Skipping explicit build (will be built during publish)..." -ForegroundColor Gray
}

Write-Host "✅ Build complete" -ForegroundColor Green
Write-Host ""

# Build Tray App
# Optimization: Skip explicit build if we are going to publish
if (-not $Publish) {
    Write-Host "Building Tray App ($Configuration)..." -ForegroundColor Yellow
    $TrayBuildParams = @("Pankha.Tray\Pankha.Tray.csproj", "-c", $Configuration)
    if ($AppIconPath) { $TrayBuildParams += "/p:AppIconPath=`"$AppIconPath`"" }
    dotnet build @TrayBuildParams
    Write-Host "✅ Tray App Build complete" -ForegroundColor Green
    Write-Host ""
}

# Test if requested
if ($Test) {
    Write-Host "Running hardware discovery test..." -ForegroundColor Yellow
    dotnet run -c $Configuration -- --test
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Test failed" -ForegroundColor Red
        exit 1
    }
    Write-Host "✅ Test complete" -ForegroundColor Green
    Write-Host ""
}

# Publish if requested
if ($Publish) {
    Write-Host "Publishing single-file executable..." -ForegroundColor Yellow

    # Resolve relative path from config
    $OutputDir = Join-Path $PSScriptRoot $Config.Paths.BuildArtifacts
    
    # Clean output dir
    if (Test-Path $OutputDir) { Remove-Item -Recurse -Force $OutputDir }

    $PublishArgs = @(
        "-c", "Release",
        "-r", "win-x64",
        "--self-contained", "true",
        "/p:PublishSingleFile=true",
        "/p:IncludeNativeLibrariesForSelfExtract=true",
        "/p:PublishReadyToRun=true",
        "-o", $OutputDir
    )
    if ($AppIconPath) { $PublishArgs += "/p:ApplicationIcon=`"$AppIconPath`"" }

    dotnet publish @PublishArgs

    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Publish failed" -ForegroundColor Red
        exit 1
    }

    # Publish Tray App
    Write-Host "Publishing Tray App..." -ForegroundColor Yellow
    $TrayPublishArgs = @(
        "Pankha.Tray\Pankha.Tray.csproj",
        "-c", "Release",
        "-r", "win-x64",
        "--self-contained", "true",
        "/p:PublishSingleFile=true",
        "/p:IncludeNativeLibrariesForSelfExtract=true",
        "-o", $OutputDir
    )
    if ($AppIconPath) {
        $TrayPublishArgs += "/p:ApplicationIcon=`"$AppIconPath`""
        $TrayPublishArgs += "/p:AppIconPath=`"$AppIconPath`""
    }

    dotnet publish @TrayPublishArgs
    if ($LASTEXITCODE -ne 0) {
        Write-Host "❌ Tray App Publish failed" -ForegroundColor Red
        exit 1
    }

    # Rename Tray Executable
    $DefaultTrayName = "Pankha.Tray.exe"
    $TargetTrayName = $Config.Filenames.AgentUI

    if ($TargetTrayName -and $TargetTrayName -ne $DefaultTrayName) {
        $SourceTray = Join-Path $OutputDir $DefaultTrayName
        $TargetTray = Join-Path $OutputDir $TargetTrayName
        if (Test-Path $SourceTray) {
            Move-Item -Force $SourceTray $TargetTray
            Write-Host "Renamed Tray executable to: $TargetTrayName" -ForegroundColor Gray
        }
    }

    # Copy configuration example
    Copy-Item "config.example.json" "$OutputDir\config.example.json"

    # Note: ui-options.json is embedded as a resource in Pankha.Tray at build-time
    # (from frontend/src/config/ui-options.json) - no runtime file needed

    # Rename Executable if needed (Default is project name pankha-agent-windows.exe)
    # If Config.Filenames.AgentExe differs, we rename it.
    
    $TargetExeName = $Config.Filenames.AgentExe
    $ExpectedOutput = Join-Path $OutputDir $TargetExeName

    if (-not (Test-Path $ExpectedOutput)) {
        # Fallback: Check if it was output with default name (if props failed)
        $DefaultProjectName = "pankha-agent-windows.exe"
        $PossibleDefault = Join-Path $OutputDir $DefaultProjectName
        if (Test-Path $PossibleDefault) {
             Move-Item -Force $PossibleDefault $ExpectedOutput
             Write-Host "Renamed executable to: $TargetExeName" -ForegroundColor Gray
        } else {
             # It might already be named correctly if Directory.Build.props worked
             # But if Test-Path $ExpectedOutput failed, then it's NOT there.
             # So we warn.
             Write-Host "WARNING: Expected executable not found at $ExpectedOutput" -ForegroundColor Yellow
        }
    }

    Write-Host "✅ Publish complete" -ForegroundColor Green
    Write-Host ""
    Write-Host "Output: $OutputDir\$TargetExeName" -ForegroundColor Cyan

    # Show file size
    $ExePath = "$OutputDir\$TargetExeName"
    if (Test-Path $ExePath) {
        $Size = (Get-Item $ExePath).Length / 1MB
        Write-Host "Size: $($Size.ToString('F2')) MB" -ForegroundColor Cyan
    }
}

# Build MSI installer if requested (WixSharp)
if ($BuildInstaller) {
    Write-Host ""
    Write-Host "=== Building WixSharp MSI Installer ===" -ForegroundColor Cyan
    Write-Host ""

    Push-Location installer
    try {
        # Call the WixSharp build script
        $buildArgs = @()
        if ($Clean) {
            $buildArgs += "-Clean"
        }

        Write-Host "Running WixSharp installer builder..." -ForegroundColor Yellow
        & .\build-wixsharp.ps1 @buildArgs

        if ($LASTEXITCODE -ne 0) {
            throw "WixSharp installer build failed"
        }

        Write-Host ""
        Write-Host "✅ MSI Installer build complete!" -ForegroundColor Green
        Write-Host ""

        # Show MSI location - Resolve from Config
        $MsiOutputDir = Join-Path $PSScriptRoot $Config.Paths.InstallerOutput
        $MsiFileName = $Config.Filenames.InstallerMsi
        $MsiPath = Join-Path $MsiOutputDir $MsiFileName
        
        if (Test-Path $MsiPath) {
            $MsiSize = (Get-Item $MsiPath).Length / 1MB
            Write-Host "========================================" -ForegroundColor Cyan
            Write-Host " MSI Installer Ready!" -ForegroundColor Green
            Write-Host "========================================" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "Location: $MsiPath" -ForegroundColor Cyan
            Write-Host "Size: $($MsiSize.ToString('F2')) MB" -ForegroundColor Cyan
            Write-Host ""
            Write-Host "To install:" -ForegroundColor Yellow
            Write-Host "  msiexec /i `"$MsiPath`" /l*v install.log" -ForegroundColor Gray
            Write-Host "  (or double-click the MSI file)" -ForegroundColor Gray
            Write-Host ""
            Write-Host "To uninstall:" -ForegroundColor Yellow
            Write-Host "  msiexec /x `"$MsiPath`" /l*v uninstall.log" -ForegroundColor Gray
            Write-Host ""
        }
    }
    catch {
        Write-Host "❌ Installer build failed: $_" -ForegroundColor Red
        Pop-Location
        exit 1
    }
    finally {
        Pop-Location
    }
}

Write-Host ""
Write-Host "Finished at: $(Get-Date -Format 'yyyy-MM-dd hh:mm:ss tt')" -ForegroundColor Gray
Write-Host "=== Build Complete ===" -ForegroundColor Cyan
