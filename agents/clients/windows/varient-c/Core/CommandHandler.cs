using Newtonsoft.Json;
using Pankha.Tray.Models;
using Pankha.WindowsAgent.Hardware;
using Pankha.WindowsAgent.Models.Configuration;
using Pankha.WindowsAgent.Models.Messages;
using Serilog;

namespace Pankha.WindowsAgent.Core;

/// <summary>
/// Handles commands received from backend
/// Unified schema - sensor deduplication commands removed
/// </summary>
public class CommandHandler
{
    private readonly IHardwareMonitor _hardwareMonitor;
    private readonly AgentConfig _config;
    private readonly ILogger _logger;

    public CommandHandler(IHardwareMonitor hardwareMonitor, AgentConfig config, ILogger logger)
    {
        _hardwareMonitor = hardwareMonitor;
        _config = config;
        _logger = logger;
    }

    /// <summary>
    /// Handle a command and return response
    /// </summary>
    public async Task<CommandResponse> HandleCommandAsync(
        string commandType,
        string commandId,
        Dictionary<string, object> payload)
    {
        try
        {
            switch (commandType)
            {
                case "setFanSpeed":
                    return await HandleSetFanSpeedAsync(commandId, payload);

                case "emergencyStop":
                    return await HandleEmergencyStopAsync(commandId);

                case "setUpdateInterval":
                    return await HandleSetUpdateIntervalAsync(commandId, payload);

                // Sensor deduplication commands removed (deprecated feature)

                case "setFanStep":
                    return await HandleSetFanStepAsync(commandId, payload);

                case "setHysteresis":
                    return await HandleSetHysteresisAsync(commandId, payload);

                case "setEmergencyTemp":
                    return await HandleSetEmergencyTempAsync(commandId, payload);

                case "setLogLevel":
                    return await HandleSetLogLevelAsync(commandId, payload);

                case "setFailsafeSpeed":
                    return await HandleSetFailsafeSpeedAsync(commandId, payload);

                case "setEnableFanControl":
                    return await HandleSetEnableFanControlAsync(commandId, payload);

                case "setAgentName":
                    return await HandleSetAgentNameAsync(commandId, payload);

                case "ping":
                    return CreateSuccessResponse(commandId, new { pong = true });

                case "getDiagnostics":
                    return await HandleGetDiagnosticsAsync(commandId);

                default:
                    return CreateErrorResponse(commandId, $"Unknown command type: {commandType}");
            }
        }
        catch (Exception ex)
        {
            _logger.Error(ex, "Error handling command {CommandType}", commandType);
            return CreateErrorResponse(commandId, ex.Message);
        }
    }

    private async Task<CommandResponse> HandleSetFanSpeedAsync(string commandId, Dictionary<string, object> payload)
    {
        // Check if fan control is enabled (matching Rust agent behavior)
        if (!_config.Hardware.EnableFanControl)
        {
            _logger.Debug("Ignoring setFanSpeed command (fan control disabled)");
            return CreateSuccessResponse(commandId, new { message = "Fan control is disabled" });
        }

        var fanId = GetPayloadValue<string>(payload, "fanId");
        var speed = GetPayloadValue<int>(payload, "speed");

        _logger.Debug("Set fan {FanId} to {Speed}%", fanId, speed);

        await _hardwareMonitor.SetFanSpeedAsync(fanId, speed);

        return CreateSuccessResponse(commandId, new { fanId, speed });
    }

    private async Task<CommandResponse> HandleEmergencyStopAsync(string commandId)
    {
        _logger.Warning("EMERGENCY STOP activated");

        await _hardwareMonitor.EmergencyStopAsync();

        return CreateSuccessResponse(commandId, new { message = "Emergency stop executed" });
    }

    private Task<CommandResponse> HandleSetUpdateIntervalAsync(string commandId, Dictionary<string, object> payload)
    {
        var interval = GetPayloadValue<double>(payload, "interval");

        // Validate using SST values (auto-generated from ui-options.json)
        if (!UIOptionsAutoGenerated.ValidUpdateIntervals.Contains(interval))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Update interval must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidUpdateIntervals)}"));
        }

        var oldInterval = _config.Agent.UpdateInterval;
        _config.Agent.UpdateInterval = interval;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Update Interval changed: {Old}s → {New}s", oldInterval, interval);

        return Task.FromResult(CreateSuccessResponse(commandId, new { interval }));
    }

    private Task<CommandResponse> HandleSetFanStepAsync(string commandId, Dictionary<string, object> payload)
    {
        var step = GetPayloadValue<int>(payload, "step");

        // Validate using SST values (auto-generated from ui-options.json)
        if (!UIOptionsAutoGenerated.ValidFanSteps.Contains(step))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Fan step must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidFanSteps)}"));
        }

        var oldStep = _config.Hardware.FanStepPercent;
        _config.Hardware.FanStepPercent = step;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Fan Step changed: {Old}% → {New}%", oldStep, step);

        return Task.FromResult(CreateSuccessResponse(commandId, new { step }));
    }

    private Task<CommandResponse> HandleSetHysteresisAsync(string commandId, Dictionary<string, object> payload)
    {
        var hysteresis = GetPayloadValue<double>(payload, "hysteresis");

        // Validate using SST values (auto-generated from ui-options.json)
        if (!UIOptionsAutoGenerated.ValidHysteresis.Contains(hysteresis))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Hysteresis must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidHysteresis)}"));
        }

        var oldHysteresis = _config.Hardware.HysteresisTemp;
        _config.Hardware.HysteresisTemp = hysteresis;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Hysteresis changed: {Old}°C → {New}°C", oldHysteresis, hysteresis);

        return Task.FromResult(CreateSuccessResponse(commandId, new { hysteresis }));
    }

    private Task<CommandResponse> HandleSetEmergencyTempAsync(string commandId, Dictionary<string, object> payload)
    {
        var temp = GetPayloadValue<double>(payload, "temp");

        // Validate using SST values (auto-generated from ui-options.json)
        if (!UIOptionsAutoGenerated.ValidEmergencyTemps.Contains((int)temp))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Emergency temp must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidEmergencyTemps)}"));
        }

        var oldTemp = _config.Hardware.EmergencyTemp;
        _config.Hardware.EmergencyTemp = temp;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Emergency Temp changed: {Old}°C → {New}°C", oldTemp, temp);

        return Task.FromResult(CreateSuccessResponse(commandId, new { temp = temp }));
    }

    private Task<CommandResponse> HandleSetLogLevelAsync(string commandId, Dictionary<string, object> payload)
    {
        var level = GetPayloadValue<string>(payload, "level");

        // Validate using SST values (auto-generated from ui-options.json)
        var upperLevel = level.ToUpperInvariant();
        if (!UIOptionsAutoGenerated.ValidLogLevels.Select(l => l.ToUpperInvariant()).Contains(upperLevel))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Log level must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidLogLevels)}"));
        }

        // Save to config file (now in Agent section)
        var oldLevel = _config.Agent.LogLevel;
        _config.Agent.LogLevel = upperLevel;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        // Map to Serilog level
        var serilogLevel = upperLevel switch
        {
            "TRACE" => Serilog.Events.LogEventLevel.Verbose,
            "DEBUG" => Serilog.Events.LogEventLevel.Debug,
            "INFO" => Serilog.Events.LogEventLevel.Information,
            "WARN" => Serilog.Events.LogEventLevel.Warning,
            "ERROR" => Serilog.Events.LogEventLevel.Error,
            "CRITICAL" => Serilog.Events.LogEventLevel.Fatal,
            _ => Serilog.Events.LogEventLevel.Information
        };

        // Update the global LoggingLevelSwitch - this dynamically changes ALL loggers
        Pankha.WindowsAgent.Program.LogLevelSwitch.MinimumLevel = serilogLevel;

        _logger.Information("✏️ Log Level changed: {Old} → {New}", oldLevel, upperLevel);

        return Task.FromResult(CreateSuccessResponse(commandId, new { level = upperLevel }));
    }

    private Task<CommandResponse> HandleSetFailsafeSpeedAsync(string commandId, Dictionary<string, object> payload)
    {
        var speed = GetPayloadValue<int>(payload, "speed");

        // Validate using SST values (auto-generated from ui-options.json)
        if (!UIOptionsAutoGenerated.ValidFailsafeSpeeds.Contains(speed))
        {
            return Task.FromResult(CreateErrorResponse(commandId, $"Failsafe speed must be one of: {string.Join(", ", UIOptionsAutoGenerated.ValidFailsafeSpeeds)}"));
        }

        var oldSpeed = _config.Hardware.FailsafeSpeed;
        _config.Hardware.FailsafeSpeed = speed;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Failsafe Speed changed: {Old}% → {New}%", oldSpeed, speed);

        return Task.FromResult(CreateSuccessResponse(commandId, new { speed }));
    }

    private Task<CommandResponse> HandleSetEnableFanControlAsync(string commandId, Dictionary<string, object> payload)
    {
        var enabled = GetPayloadValue<bool>(payload, "enabled");

        var oldEnabled = _config.Hardware.EnableFanControl;
        _config.Hardware.EnableFanControl = enabled;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        var status = enabled ? "enabled" : "disabled";
        var oldStatus = oldEnabled ? "enabled" : "disabled";
        _logger.Information("✏️ Fan Control changed: {Old} → {New}", oldStatus, status);

        return Task.FromResult(CreateSuccessResponse(commandId, new { enabled }));
    }

    private Task<CommandResponse> HandleSetAgentNameAsync(string commandId, Dictionary<string, object> payload)
    {
        var name = GetPayloadValue<string>(payload, "name");

        // Validate name
        if (string.IsNullOrWhiteSpace(name))
        {
            return Task.FromResult(CreateErrorResponse(commandId, "Agent name cannot be empty"));
        }

        var trimmedName = name.Trim();
        if (trimmedName.Length > 255)
        {
            return Task.FromResult(CreateErrorResponse(commandId, "Agent name must be 255 characters or less"));
        }

        // Update config
        var oldName = _config.Agent.Name;
        _config.Agent.Name = trimmedName;
        _config.SaveToFile(Pankha.WindowsAgent.Platform.PathResolver.ConfigPath);

        _logger.Information("✏️ Agent Name changed: {Old} → {New}", oldName, trimmedName);

        return Task.FromResult(CreateSuccessResponse(commandId, new { name = trimmedName }));
    }

    private async Task<CommandResponse> HandleGetDiagnosticsAsync(string commandId)
    {
        _logger.Information("Generating fresh hardware diagnostics for remote request");

        try
        {
            // Generate fresh hardware dump
            var dumpRoot = await _hardwareMonitor.DumpFullHardwareInfoAsync();
            
            // Convert to dictionary for response
            var json = JsonConvert.SerializeObject(dumpRoot);
            var diagnosticsData = JsonConvert.DeserializeObject<Dictionary<string, object>>(json);

            return CreateSuccessResponse(commandId, diagnosticsData ?? new Dictionary<string, object>());
        }
        catch (Exception ex)
        {
            _logger.Error(ex, "Failed to generate diagnostics");
            return CreateErrorResponse(commandId, $"Failed to generate diagnostics: {ex.Message}");
        }
    }

    private T GetPayloadValue<T>(Dictionary<string, object> payload, string key)
    {
        if (!payload.TryGetValue(key, out var value))
        {
            throw new ArgumentException($"Missing required parameter: {key}");
        }

        try
        {
            // Handle JSON deserialization for complex types
            if (value is Newtonsoft.Json.Linq.JToken jToken)
            {
                return jToken.ToObject<T>() ?? throw new InvalidCastException($"Failed to convert {key} to {typeof(T).Name}");
            }

            return (T)Convert.ChangeType(value, typeof(T));
        }
        catch (Exception ex)
        {
            throw new ArgumentException($"Invalid value for parameter '{key}': {ex.Message}", ex);
        }
    }

    private CommandResponse CreateSuccessResponse(string commandId, object data)
    {
        return new CommandResponse
        {
            CommandId = commandId,
            Success = true,
            Data = data as Dictionary<string, object> ??
                   JsonConvert.DeserializeObject<Dictionary<string, object>>(JsonConvert.SerializeObject(data)),
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
    }

    private CommandResponse CreateErrorResponse(string commandId, string error)
    {
        return new CommandResponse
        {
            CommandId = commandId,
            Success = false,
            Error = error,
            Timestamp = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()
        };
    }
}
