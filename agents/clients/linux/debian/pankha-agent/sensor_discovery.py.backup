#!/usr/bin/env python3
"""
Pankha Agent - Dynamic Sensor Discovery Module

Discovers temperature sensors, fans, and hardware monitoring interfaces
across different Linux systems without hardcoded paths.
"""

import os
import glob
import json
from datetime import datetime
from typing import Dict, List, Optional, Any


class SensorDiscovery:
    """Dynamic sensor discovery for Linux hardware monitoring."""

    # Chip priority ranking (higher = preferred)
    CHIP_PRIORITY = {
        'k10temp': 100,      # AMD CPU sensors (native)
        'coretemp': 100,     # Intel CPU sensors (native)
        'it8628': 90,        # Motherboard chip sensors (native)
        'it87': 90,          # Motherboard chip sensors (native)
        'nvme': 80,          # NVMe drive sensors
        'gigabyte_wmi': 50,  # WMI sensors (often duplicate motherboard sensors)
        'asus_wmi': 50,      # WMI sensors (often duplicate)
        'acpitz': 40,        # ACPI thermal zones (often duplicate)
    }

    def __init__(self, filter_duplicate_sensors: bool = True, duplicate_sensor_tolerance: float = 0.5):
        self.hwmon_base = "/sys/class/hwmon"
        self.thermal_base = "/sys/class/thermal"
        self.discovered_sensors = {}
        self.discovered_fans = {}
        self.filter_duplicate_sensors = filter_duplicate_sensors
        self.duplicate_sensor_tolerance = duplicate_sensor_tolerance
        self._sensor_identity_cache = {}  # Cache to maintain stable sensor list
        
    def discover_all(self) -> Dict[str, Any]:
        """Discover all available sensors and fans on the system."""
        try:
            # Discover temperature sensors
            hwmon_sensors = self._discover_hwmon_sensors()
            thermal_sensors = self._discover_thermal_zones()

            # Combine all sensors
            all_sensors = hwmon_sensors + thermal_sensors

            import os
            if os.getenv('DEBUG_DEDUP') == '1':
                print(f"\n=== BEFORE DEDUPLICATION ===")
                print(f"Discovered {len(all_sensors)} total sensors")

            # Apply deduplication if enabled
            if self.filter_duplicate_sensors:
                all_sensors = self._deduplicate_sensors(all_sensors)

                if os.getenv('DEBUG_DEDUP') == '1':
                    print(f"\n=== AFTER DEDUPLICATION ===")
                    print(f"Kept {len(all_sensors)} sensors")

            # Discover fans and PWM controls
            fans = self._discover_fans()

            # Combine all discoveries
            discovery_data = {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "sensors": all_sensors,  # Unified sensor list
                "hwmon_sensors": hwmon_sensors,  # Keep original for debugging
                "thermal_sensors": thermal_sensors,  # Keep original for debugging
                "fans": fans,
                "sensor_count": len(all_sensors),
                "fan_count": len(fans),
                "deduplication_enabled": self.filter_duplicate_sensors
            }

            return discovery_data

        except Exception as e:
            return {
                "error": f"Discovery failed: {str(e)}",
                "timestamp": datetime.utcnow().isoformat() + "Z"
            }

    def _deduplicate_sensors(self, sensors: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Remove duplicate sensors based on temperature values and chip priority.

        Strategy:
        1. Group sensors by temperature value (with tolerance of ±2.0°C)
        2. Within each group, keep only the sensor from the highest priority chip
        3. Remove thermal zones that duplicate hwmon sensors

        Note: Increased tolerance from 0.5°C to 2.0°C to prevent flickering
        as temperatures fluctuate slightly on each scan.
        """
        if not sensors:
            return sensors

        # Temperature tolerance for considering sensors as duplicates (in Celsius)
        # Use configured tolerance from agent config
        TEMP_TOLERANCE = self.duplicate_sensor_tolerance

        # First, create stable sensor identities based on path/chip
        sensor_identities = {}
        import os
        debug = os.getenv('DEBUG_DEDUP') == '1'

        for sensor in sensors:
            # Create unique identity using sensor ID (which is already unique)
            # This ensures each sensor is treated independently
            sensor_id = sensor.get('id', '')
            chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
            identity = f"{chip}:{sensor_id}"

            if debug and identity in sensor_identities:
                print(f"WARNING: Duplicate identity '{identity}' - overwriting!")
                print(f"  Old: {sensor_identities[identity]['id']}")
                print(f"  New: {sensor['id']}")

            sensor_identities[identity] = sensor

        if debug:
            print(f"\nCreated {len(sensor_identities)} unique identities from {len(sensors)} sensors")

        # Now group by temperature to find duplicates
        temp_groups = {}
        import os
        debug = os.getenv('DEBUG_DEDUP') == '1'

        for identity, sensor in sensor_identities.items():
            temp = sensor.get('value', 0)
            chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
            sensor_id = sensor.get('id', 'unknown')

            # Find if this temperature matches an existing group (within tolerance)
            matched_group = None
            for group_temp in temp_groups.keys():
                if abs(temp - group_temp) <= TEMP_TOLERANCE:
                    matched_group = group_temp
                    if debug:
                        print(f"  {sensor_id:30s} {temp:5.1f}°C matches group {group_temp:5.1f}°C (diff={abs(temp-group_temp):4.2f}°C)")
                    break

            # Add to existing group or create new one
            if matched_group is not None:
                temp_groups[matched_group].append((identity, sensor))
            else:
                if debug:
                    print(f"  {sensor_id:30s} {temp:5.1f}°C creates new group")
                temp_groups[temp] = [(identity, sensor)]

        # For each temperature group, deduplicate intelligently
        # IMPORTANT: Keep ALL sensors from the same chip even if they have similar temps
        # Only filter duplicates across DIFFERENT chips (e.g., WMI duplicates of it8628)
        deduplicated = []

        import os
        debug = os.getenv('DEBUG_DEDUP') == '1'

        for temp, group in temp_groups.items():
            if debug:
                print(f"\nProcessing temp group ~{temp}°C with {len(group)} sensors")
                for identity, sensor in group:
                    chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
                    print(f"    {chip:15s} {sensor['id']:30s} {sensor['value']}°C")
            if len(group) == 1:
                # No duplicates, keep the sensor
                identity, sensor = group[0]
                deduplicated.append(sensor)
                self._sensor_identity_cache[identity] = sensor
            else:
                # Multiple sensors with same temperature
                # Group by chip to identify which sensors are from the same source
                chip_groups = {}
                for identity, sensor in group:
                    chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
                    if chip not in chip_groups:
                        chip_groups[chip] = []
                    chip_groups[chip].append((identity, sensor))

                # If ALL sensors in this temp group are from the SAME chip,
                # keep them ALL (they're measuring different locations)
                if len(chip_groups) == 1:
                    # All from same chip - keep ALL
                    if debug:
                        chip_name = list(chip_groups.keys())[0]
                        print(f"  Single chip ({chip_name}) - keeping all {len(group)} sensors")
                    for identity, sensor in group:
                        deduplicated.append(sensor)
                        self._sensor_identity_cache[identity] = sensor
                else:
                    # Multiple different chips with same temperature
                    # Keep the highest priority chip, but keep ALL sensors from that chip
                    # Determine which chip to keep (use cached decision or priority)
                    selected_chip = None

                    # Check cache first
                    for identity, sensor in group:
                        if identity in self._sensor_identity_cache:
                            selected_chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
                            break

                    # No cache hit, select by priority
                    if selected_chip is None:
                        sensors_only = [s for _, s in group]
                        best_sensor = self._select_best_sensor(sensors_only)
                        selected_chip = best_sensor.get('chip', best_sensor.get('zone_type', 'unknown'))

                    # Keep ALL sensors from the selected chip (IN THIS GROUP)
                    kept_count = 0
                    for identity, sensor in group:
                        chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))
                        if chip == selected_chip:
                            deduplicated.append(sensor)
                            self._sensor_identity_cache[identity] = sensor
                            kept_count += 1
                    if debug:
                        print(f"  Multi-chip group ({len(chip_groups)} chips) - selected {selected_chip}, kept {kept_count} sensors")

        return deduplicated

    def _select_best_sensor(self, sensors: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Select the best sensor from a group of duplicate sensors.

        Priority rules:
        1. Prefer sensors from higher priority chips (e.g., k10temp over WMI)
        2. Prefer sensors with more metadata (max/crit values)
        3. Prefer hwmon over thermal zones
        """
        def get_priority(sensor: Dict[str, Any]) -> int:
            chip = sensor.get('chip', sensor.get('zone_type', 'unknown'))

            # Get base priority from chip type
            base_priority = self.CHIP_PRIORITY.get(chip, 30)

            # Bonus for having temperature limits
            has_limits = 'max_value' in sensor or 'critical_value' in sensor
            limits_bonus = 10 if has_limits else 0

            # Bonus for hwmon over thermal zones
            hwmon_bonus = 5 if 'hwmon' in sensor else 0

            return base_priority + limits_bonus + hwmon_bonus

        # Sort by priority (descending) and return the best one
        sorted_sensors = sorted(sensors, key=get_priority, reverse=True)
        return sorted_sensors[0]

    def _discover_hwmon_sensors(self) -> List[Dict[str, Any]]:
        """Discover hardware monitoring sensors via /sys/class/hwmon."""
        sensors = []
        
        if not os.path.exists(self.hwmon_base):
            return sensors
            
        # Find all hwmon interfaces
        hwmon_dirs = glob.glob(f"{self.hwmon_base}/hwmon*")
        
        for hwmon_dir in sorted(hwmon_dirs):
            hwmon_name = os.path.basename(hwmon_dir)
            
            # Get hwmon chip name
            chip_name = self._read_file(f"{hwmon_dir}/name", "unknown")
            
            # Find all temperature inputs
            temp_files = glob.glob(f"{hwmon_dir}/temp*_input")
            
            for temp_file in sorted(temp_files):
                sensor_info = self._parse_hwmon_sensor(hwmon_dir, temp_file, chip_name)
                if sensor_info:
                    sensors.append(sensor_info)
                    
        return sensors
    
    def _discover_thermal_zones(self) -> List[Dict[str, Any]]:
        """Discover thermal zones via /sys/class/thermal."""
        sensors = []
        
        if not os.path.exists(self.thermal_base):
            return sensors
            
        # Find all thermal zones
        thermal_dirs = glob.glob(f"{self.thermal_base}/thermal_zone*")
        
        for thermal_dir in sorted(thermal_dirs):
            zone_name = os.path.basename(thermal_dir)
            
            # Get thermal zone type
            zone_type = self._read_file(f"{thermal_dir}/type", "unknown")
            
            # Get current temperature
            temp_file = f"{thermal_dir}/temp"
            if os.path.exists(temp_file):
                sensor_info = self._parse_thermal_sensor(thermal_dir, temp_file, zone_type)
                if sensor_info:
                    sensors.append(sensor_info)
                    
        return sensors
    
    def _discover_fans(self) -> List[Dict[str, Any]]:
        """Discover fans and PWM controls."""
        fans = []
        
        if not os.path.exists(self.hwmon_base):
            return fans
            
        # Find all hwmon interfaces
        hwmon_dirs = glob.glob(f"{self.hwmon_base}/hwmon*")
        
        for hwmon_dir in sorted(hwmon_dirs):
            hwmon_name = os.path.basename(hwmon_dir)
            chip_name = self._read_file(f"{hwmon_dir}/name", "unknown")
            
            # Find all fan inputs
            fan_files = glob.glob(f"{hwmon_dir}/fan*_input")
            
            for fan_file in sorted(fan_files):
                fan_info = self._parse_fan(hwmon_dir, fan_file, chip_name)
                if fan_info:
                    fans.append(fan_info)
                    
        return fans
    
    def _parse_hwmon_sensor(self, hwmon_dir: str, temp_file: str, chip_name: str) -> Optional[Dict[str, Any]]:
        """Parse individual hwmon temperature sensor."""
        try:
            # Extract sensor number from filename (temp1_input -> 1)
            temp_num = os.path.basename(temp_file).split("_")[0][4:]  # Remove "temp" prefix
            
            # Read current temperature (in millidegrees)
            temp_raw = self._read_file(temp_file)
            if temp_raw is None:
                return None
                
            temp_celsius = float(temp_raw) / 1000.0
            
            # Try to get sensor label
            label_file = f"{hwmon_dir}/temp{temp_num}_label"
            sensor_label = self._read_file(label_file, f"Sensor {temp_num}")
            
            # Try to get limits
            max_file = f"{hwmon_dir}/temp{temp_num}_max"
            crit_file = f"{hwmon_dir}/temp{temp_num}_crit"
            
            max_temp = self._read_file(max_file)
            crit_temp = self._read_file(crit_file)
            
            # Generate unique sensor ID
            sensor_id = f"{chip_name}_{temp_num}".lower().replace(" ", "_")
            
            sensor_info = {
                "id": sensor_id,
                "name": f"{chip_name} {sensor_label}",
                "type": "temperature",
                "value": round(temp_celsius, 1),
                "unit": "celsius",
                "source": temp_file,
                "chip": chip_name,
                "hwmon": os.path.basename(hwmon_dir)
            }
            
            # Add limits if available
            if max_temp is not None:
                sensor_info["max_value"] = float(max_temp) / 1000.0
            if crit_temp is not None:
                sensor_info["critical_value"] = float(crit_temp) / 1000.0
                
            return sensor_info
            
        except Exception as e:
            print(f"Error parsing hwmon sensor {temp_file}: {e}")
            return None
    
    def _parse_thermal_sensor(self, thermal_dir: str, temp_file: str, zone_type: str) -> Optional[Dict[str, Any]]:
        """Parse individual thermal zone sensor."""
        try:
            # Read current temperature (in millidegrees)
            temp_raw = self._read_file(temp_file)
            if temp_raw is None:
                return None
                
            temp_celsius = float(temp_raw) / 1000.0
            
            zone_name = os.path.basename(thermal_dir)
            sensor_id = f"thermal_{zone_name}_{zone_type}".lower().replace(" ", "_")
            
            sensor_info = {
                "id": sensor_id,
                "name": f"Thermal Zone {zone_type}",
                "type": "temperature", 
                "value": round(temp_celsius, 1),
                "unit": "celsius",
                "source": temp_file,
                "thermal_zone": zone_name,
                "zone_type": zone_type
            }
            
            return sensor_info
            
        except Exception as e:
            print(f"Error parsing thermal sensor {temp_file}: {e}")
            return None
    
    def _parse_fan(self, hwmon_dir: str, fan_file: str, chip_name: str) -> Optional[Dict[str, Any]]:
        """Parse individual fan sensor."""
        try:
            # Extract fan number from filename (fan1_input -> 1)
            fan_num = os.path.basename(fan_file).split("_")[0][3:]  # Remove "fan" prefix
            
            # Read current RPM
            rpm_raw = self._read_file(fan_file)
            if rpm_raw is None:
                return None
                
            rpm = int(rpm_raw)
            
            # Check for corresponding PWM control
            pwm_file = f"{hwmon_dir}/pwm{fan_num}"
            pwm_enable_file = f"{hwmon_dir}/pwm{fan_num}_enable"
            
            has_pwm_control = os.path.exists(pwm_file)
            pwm_value = None
            pwm_enabled = None
            
            if has_pwm_control:
                pwm_value = self._read_file(pwm_file)
                pwm_enabled = self._read_file(pwm_enable_file)
            
            # Generate unique fan ID
            fan_id = f"{chip_name}_fan_{fan_num}".lower().replace(" ", "_")
            
            fan_info = {
                "id": fan_id,
                "name": f"{chip_name} Fan {fan_num}",
                "type": "fan",
                "rpm": rpm,
                "source": fan_file,
                "chip": chip_name,
                "hwmon": os.path.basename(hwmon_dir),
                "fan_number": int(fan_num),
                "has_pwm_control": has_pwm_control
            }
            
            # Add PWM info if available
            if has_pwm_control:
                fan_info["pwm_file"] = pwm_file
                fan_info["pwm_enable_file"] = pwm_enable_file
                if pwm_value is not None:
                    fan_info["pwm_value"] = int(pwm_value)
                if pwm_enabled is not None:
                    fan_info["pwm_enabled"] = int(pwm_enabled)
                    
            return fan_info
            
        except Exception as e:
            print(f"Error parsing fan {fan_file}: {e}")
            return None
    
    def _read_file(self, filepath: str, default: Optional[str] = None) -> Optional[str]:
        """Safely read a file and return its content."""
        try:
            if not os.path.exists(filepath):
                return default
                
            with open(filepath, "r") as f:
                content = f.read().strip()
                return content if content else default
                
        except Exception:
            return default


def main():
    """Test sensor discovery functionality."""
    discovery = SensorDiscovery()
    result = discovery.discover_all()
    print(json.dumps(result, indent=2))


if __name__ == "__main__":
    main()
