//! Build script for Pankha Agent
//! Generates SST (Single Source of Truth) validation arrays from ui-options.json
//! at compile time, ensuring Linux Rust agent uses same values as frontend/Windows agent.

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=../../../../../../frontend/src/config/ui-options.json");
    println!("cargo:rerun-if-changed=build.rs");

    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("sst_validation.rs");

    // Try to find ui-options.json relative to the build script
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let ui_options_path = Path::new(&manifest_dir)
        .join("../../../../../../frontend/src/config/ui-options.json");

    let generated_code = if ui_options_path.exists() {
        match generate_from_json(&ui_options_path) {
            Ok(code) => {
                println!("cargo:warning=SST: Generated validation from ui-options.json");
                code
            }
            Err(e) => {
                println!("cargo:warning=SST: Failed to parse ui-options.json: {}", e);
                generate_fallback()
            }
        }
    } else {
        println!("cargo:warning=SST: ui-options.json not found at {:?}, using fallback", ui_options_path);
        generate_fallback()
    };

    fs::write(&dest_path, generated_code).expect("Failed to write sst_validation.rs");
}

fn generate_from_json(path: &Path) -> Result<String, Box<dyn std::error::Error>> {
    let content = fs::read_to_string(path)?;
    let json: serde_json::Value = serde_json::from_str(&content)?;

    let options = json.get("options").ok_or("Missing 'options' key")?;

    // Extract values from each option
    let update_intervals = extract_f64_values(options, "updateInterval")?;
    let fan_steps = extract_i32_values(options, "fanStep")?;
    let hysteresis = extract_f64_values(options, "hysteresis")?;
    let emergency_temps = extract_i32_values(options, "emergencyTemp")?;
    let log_levels = extract_string_values(options, "logLevel")?;
    let failsafe_speeds = extract_i32_values(options, "failsafeSpeed")?;

    Ok(format!(r#"// Auto-generated SST validation arrays from ui-options.json
// DO NOT EDIT - Generated by build.rs at compile time

/// Valid update interval values in seconds
pub const VALID_UPDATE_INTERVALS: &[f64] = &[{update_intervals}];

/// Valid fan step percentage values
pub const VALID_FAN_STEPS: &[u8] = &[{fan_steps}];

/// Valid hysteresis temperature values in 째C
pub const VALID_HYSTERESIS: &[f64] = &[{hysteresis}];

/// Valid emergency temperature values in 째C
pub const VALID_EMERGENCY_TEMPS: &[u8] = &[{emergency_temps}];

/// Valid log level values
pub const VALID_LOG_LEVELS: &[&str] = &[{log_levels}];

/// Valid failsafe speed percentage values
pub const VALID_FAILSAFE_SPEEDS: &[u8] = &[{failsafe_speeds}];
"#))
}

fn extract_f64_values(options: &serde_json::Value, key: &str) -> Result<String, Box<dyn std::error::Error>> {
    let values = options
        .get(key)
        .and_then(|v| v.get("values"))
        .and_then(|v| v.as_array())
        .ok_or(format!("Missing {}.values", key))?;

    let nums: Vec<String> = values
        .iter()
        .filter_map(|v| v.get("value").and_then(|v| v.as_f64()))
        .map(|n| format!("{:.1}", n))
        .collect();

    Ok(nums.join(", "))
}

fn extract_i32_values(options: &serde_json::Value, key: &str) -> Result<String, Box<dyn std::error::Error>> {
    let values = options
        .get(key)
        .and_then(|v| v.get("values"))
        .and_then(|v| v.as_array())
        .ok_or(format!("Missing {}.values", key))?;

    let nums: Vec<String> = values
        .iter()
        .filter_map(|v| v.get("value").and_then(|v| v.as_i64()))
        .map(|n| n.to_string())
        .collect();

    Ok(nums.join(", "))
}

fn extract_string_values(options: &serde_json::Value, key: &str) -> Result<String, Box<dyn std::error::Error>> {
    let values = options
        .get(key)
        .and_then(|v| v.get("values"))
        .and_then(|v| v.as_array())
        .ok_or(format!("Missing {}.values", key))?;

    let strs: Vec<String> = values
        .iter()
        .filter_map(|v| v.get("value").and_then(|v| v.as_str()))
        .map(|s| format!("\"{}\"", s))
        .collect();

    Ok(strs.join(", "))
}

fn generate_fallback() -> String {
    // Fallback values matching ui-options.json defaults
    r#"// Fallback SST validation arrays (ui-options.json not found at build time)
// These should match the values in frontend/src/config/ui-options.json

/// Valid update interval values in seconds
pub const VALID_UPDATE_INTERVALS: &[f64] = &[0.5, 1.0, 2.0, 3.0, 5.0, 7.0, 10.0, 15.0, 30.0];

/// Valid fan step percentage values
pub const VALID_FAN_STEPS: &[u8] = &[2, 3, 5, 7, 10, 15, 25, 50, 100];

/// Valid hysteresis temperature values in 째C
pub const VALID_HYSTERESIS: &[f64] = &[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 4.0, 5.0, 7.5, 10.0];

/// Valid emergency temperature values in 째C
pub const VALID_EMERGENCY_TEMPS: &[u8] = &[60, 65, 70, 75, 80, 85, 90, 95, 100];

/// Valid log level values
pub const VALID_LOG_LEVELS: &[&str] = &["TRACE", "DEBUG", "INFO", "WARN", "ERROR"];

/// Valid failsafe speed percentage values
pub const VALID_FAILSAFE_SPEEDS: &[u8] = &[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100];
"#.to_string()
}
